[{"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/index.jsx":"1","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/contexts/Application.jsx":"2","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/pages/App.jsx":"3","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/store.js":"4","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/utils/constants.js":"5","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/utils/fetch-websocket.js":"6","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/components/Header.jsx":"7","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/components/Swap.jsx":"8","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/components/Web3Status.jsx":"9","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/components/AssetInput.jsx":"10","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/components/Steps.jsx":"11"},{"size":283,"mtime":1615251694306,"results":"12","hashOfConfig":"13"},{"size":4835,"mtime":1615251694306,"results":"14","hashOfConfig":"13"},{"size":799,"mtime":1615251694306,"results":"15","hashOfConfig":"13"},{"size":5046,"mtime":1615251694306,"results":"16","hashOfConfig":"13"},{"size":247,"mtime":1615251694306,"results":"17","hashOfConfig":"18"},{"size":5178,"mtime":1615251694306,"results":"19","hashOfConfig":"18"},{"size":890,"mtime":1615251694306,"results":"20","hashOfConfig":"13"},{"size":5404,"mtime":1615251694306,"results":"21","hashOfConfig":"13"},{"size":1584,"mtime":1615251694306,"results":"22","hashOfConfig":"13"},{"size":2733,"mtime":1615251694306,"results":"23","hashOfConfig":"13"},{"size":1227,"mtime":1615251694306,"results":"24","hashOfConfig":"13"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"gesj8w",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"36"},"ed0byn",{"filePath":"37","messages":"38","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"36"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/index.jsx",[],"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/contexts/Application.jsx",[],"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/pages/App.jsx",[],"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/store.js",[],"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/utils/constants.js",["50","51"],"// Taken from window.DAPP_CONSTANTS_JSON in index.html, defaulting to .env.local.\nimport defaults from './defaults';\n\nexport default process.env.REACT_APP_DAPP_CONSTANTS_JSON\n  ? JSON.parse(process.env.REACT_APP_DAPP_CONSTANTS_JSON)\n  : defaults;\n",["52","53","54","55","56"],"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/utils/fetch-websocket.js",["57"],"import dappConstants from './constants';\n\nconst { API_URL, BRIDGE_URL, CONTRACT_NAME } = dappConstants;\n\n// === WEB SOCKET\n\nconst endpointToSocket = new Map();\n\nfunction getWebSocketEndpoint(endpoint) {\n  // TODO proxy socket.\n  let url;\n  if (endpoint === '/api') {\n    url = new URL(endpoint, API_URL || window.origin);\n  } else {\n    url = new URL(endpoint, BRIDGE_URL || window.origin);\n  }\n  url.protocol = url.protocol.replace(/^http/, 'ws');\n  return url;\n}\n\nconst walletBridgeId = 'walletBridgeIFrame';\nlet walletLoaded = false;\nconst connectSubscriptions = new Set();\nconst messageSubscriptions = new Set();\nfunction createSocket({ onConnect, onDisconnect, onMessage }, endpoint) {\n  if (endpoint === '/private/wallet-bridge') {\n    let ifr = document.getElementById(walletBridgeId);\n    if (!ifr) {\n      ifr = document.createElement('iframe');\n      ifr.id = walletBridgeId;\n      ifr.setAttribute('width', '0');\n      ifr.setAttribute('height', '0');\n      ifr.setAttribute('style', 'display: none');\n      document.body.appendChild(ifr);\n      window.addEventListener('message', ev => {\n        // console.log('dapp ui got', ev);\n        if (ev.data && ev.data.type === 'walletBridgeLoaded') {\n          walletLoaded = true;\n          for (const sub of connectSubscriptions.keys()) {\n            sub();\n          }\n          connectSubscriptions.clear();\n        } else {\n          const msg = JSON.stringify(ev.data);\n          for (const sub of messageSubscriptions.keys()) {\n            sub(msg);\n          }\n        }\n      });\n    }\n    let ifrQ = [];\n    ifr.src = `${\n      process.env.PUBLIC_URL\n    }/agoric-wallet.html?suggestedDappPetname=${encodeURIComponent(\n      CONTRACT_NAME,\n    )}`;\n    ifr.addEventListener('load', () => {\n      while (ifrQ.length) {\n        const obj = ifrQ.shift();\n        console.log('sending', obj);\n        ifr.contentWindow.postMessage(obj, window.origin);\n      }\n      ifrQ = undefined;\n    });\n    if (onMessage) {\n      messageSubscriptions.add(onMessage);\n    }\n    const messageListeners = new Set();\n    endpointToSocket.set(endpoint, {\n      send(msg) {\n        const obj = JSON.parse(msg);\n        if (ifrQ) {\n          ifrQ.push(obj);\n        } else {\n          console.log('sending', obj);\n          ifr.contentWindow.postMessage(obj, window.origin);\n        }\n      },\n      close() {\n        walletLoaded = false;\n        if (onConnect) {\n          connectSubscriptions.delete(onConnect);\n        }\n        if (onMessage) {\n          messageSubscriptions.delete(onMessage);\n        }\n        for (const sub of messageListeners.keys()) {\n          messageSubscriptions.delete(sub);\n        }\n        const ifr2 = document.getElementById(walletBridgeId);\n        if (ifr2) {\n          ifr2.src = '';\n        }\n\n        if (onDisconnect) {\n          onDisconnect();\n        }\n      },\n      addEventListener(kind, cb) {\n        if (kind !== 'message') {\n          throw Error(`Cannot bridge.addEventListener kind ${kind}`);\n        }\n        const onmsg = data => cb({ data });\n        messageListeners.add(onmsg);\n        messageSubscriptions.add(onmsg);\n      },\n      removeEventListener(kind, cb) {\n        if (kind !== 'message') {\n          throw Error(`Cannot bridge.removeEventListener kind ${kind}`);\n        }\n        messageSubscriptions.delete(cb);\n        messageListeners.delete(cb);\n      },\n    });\n\n    if (onConnect) {\n      if (walletLoaded) {\n        onConnect();\n      } else {\n        connectSubscriptions.add(onConnect);\n      }\n    }\n    return;\n  }\n\n  const socket = new WebSocket(getWebSocketEndpoint(endpoint));\n  endpointToSocket.set(endpoint, socket);\n  if (onConnect) {\n    socket.addEventListener('open', () => onConnect());\n  }\n  if (onDisconnect) {\n    socket.addEventListener('close', () => onDisconnect());\n  }\n  if (onMessage) {\n    socket.addEventListener('message', ({ data }) => onMessage(data));\n  }\n}\n\nfunction closeSocket(endpoint) {\n  const socket = endpointToSocket.get(endpoint);\n  socket.close();\n  endpointToSocket.delete(endpoint);\n}\n\nfunction getActiveSocket(endpoint) {\n  return endpointToSocket.get(endpoint);\n}\n\nexport function activateWebSocket(\n  socketListeners = {},\n  endpoint = '/private/wallet-bridge',\n) {\n  if (getActiveSocket(endpoint)) return;\n  createSocket(socketListeners, endpoint);\n}\n\nexport function deactivateWebSocket(endpoint = '/private/wallet-bridge') {\n  if (!getActiveSocket(endpoint)) return;\n  closeSocket(endpoint);\n}\n\n// === FETCH\n\nexport async function doFetch(req, endpoint = '/private/wallet-bridge') {\n  // Use the socket directly.\n  const socket = getActiveSocket(endpoint);\n  if (!socket) {\n    throw Error(`Must activate socket before doFetch to ${endpoint}`);\n  }\n\n  let resolve;\n  const p = new Promise(res => {\n    resolve = res;\n  });\n  socket.send(JSON.stringify(req));\n  const expectedResponse = `${req.type}Response`;\n  function getResponse({ data: msg }) {\n    // console.log('got', msg);\n    const obj = JSON.parse(msg);\n    if (obj.type === expectedResponse) {\n      resolve(obj);\n      socket.removeEventListener('message', getResponse);\n    }\n  }\n  socket.addEventListener('message', getResponse);\n  return p;\n}\n","/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/components/Header.jsx",[],"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/components/Swap.jsx",[],"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/components/Web3Status.jsx",[],"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/components/AssetInput.jsx",[],"/home/codefred/Documents/Glibx/dapp-autoswap/ui/src/components/Steps.jsx",[],{"ruleId":"58","severity":2,"message":"59","line":4,"column":16,"nodeType":"60","messageId":"61","endLine":4,"endColumn":23},{"ruleId":"58","severity":2,"message":"59","line":5,"column":16,"nodeType":"60","messageId":"61","endLine":5,"endColumn":23},{"ruleId":"62","replacedBy":"63"},{"ruleId":"64","replacedBy":"65"},{"ruleId":"66","replacedBy":"67"},{"ruleId":"68","replacedBy":"69"},{"ruleId":"70","replacedBy":"71"},{"ruleId":"58","severity":2,"message":"59","line":53,"column":7,"nodeType":"60","messageId":"61","endLine":53,"endColumn":14},"no-undef","'process' is not defined.","Identifier","undef","lines-around-directive",["72"],"global-require",[],"no-buffer-constructor",[],"no-new-require",[],"no-path-concat",[],"padding-line-between-statements"]